---
title: カスタムインストラクション記述ガイド
description: AIの創造性を解放する指示の書き方
priority: CRITICAL
---

# カスタムインストラクション記述の本質

## 🎯 根本原則

カスタムインストラクションは「何を作るか」ではなく「どう考えるか」を示す。

### ❌ してはいけないこと
```markdown
<!-- 悪い例：具体的実装の押し付け -->
Reactコンポーネントは必ずuseStateを使い、以下の形式で書く：
const [state, setState] = useState(initialValue);
```

### ✅ すべきこと
```markdown
<!-- 良い例：思考プロセスの提示 -->
状態管理を実装する際は：
1. 状態の必要性を問う（本当に必要か？）
2. スコープを最小化する（どこで必要か？）
3. 適切な抽象度を選ぶ（単純 vs 複雑）
```

## 📐 記述の3層構造

### 1. 原則層（Principles）
**目的**: 判断基準を与える
```markdown
## 原則
- シンプルさ優先：複雑な解決より単純な解決
- 早期失敗：問題は早期に検出し、明確に報告
- 段階的改善：完璧を待たず、機能する最小版から始める
```

### 2. アプローチ層（Approaches）
**目的**: 問題解決の思考フロー
```markdown
## アプローチ
未知の問題に直面したら：
1. 本質を抽出する（何を解決したいのか）
2. 制約を明確化する（何ができないのか）
3. 複数の選択肢を生成する
4. トレードオフを評価する
```

### 3. ヒント層（Hints）
**目的**: 判断を助ける軽い示唆
```markdown
## ヒント
- パフォーマンスより可読性（最初は）
- 標準的な方法を知っているなら、それから始める
- 不明な場合は、その旨を明確に伝える
```

## ⚖️ バランスの法則

### 具体性と抽象性
```yaml
具体的すぎる（❌）: "必ずasync/awaitを使う"
抽象的すぎる（❌）: "良いコードを書く"
適切なバランス（✅）: "非同期処理では読みやすさを優先し、エラーハンドリングを明確にする"
```

### 制約と自由
```yaml
制約しすぎ（❌）: "このパターン以外禁止"
自由すぎる（❌）: "好きにやって"
適切なバランス（✅）: "この原則に従う限り、実装方法は文脈に応じて選択"
```

## 📝 実践的な書き方

### 1. 思考トリガーを埋め込む
```markdown
## 実装前に問うべきこと
- これは本当に必要か？（YAGNI原則）
- もっとシンプルな方法はないか？（KISS原則）
- 将来の変更に対応できるか？（Open/Closed原則）
```

### 2. 判断基準を明示
```markdown
## 技術選択の判断基準
優先順位（上から順に評価）：
1. 既存コードとの一貫性
2. チームの習熟度
3. 保守性・可読性
4. パフォーマンス（必要な場合のみ）
```

### 3. エスケープハッチを用意
```markdown
## 原則の例外
以下の場合は標準的なアプローチから逸脱してもよい：
- 明確なパフォーマンス要件がある
- 外部制約（ライブラリ、API）がある
- ユーザーが明示的に指定した
```

## 🚫 アンチパターン集

### 1. コード例の羅列
```markdown
❌ 避けるべき記述：
「以下のコードを参考にしてください」
[100行のコード例]
```

### 2. ツール固有の指定
```markdown
❌ 避けるべき記述：
「必ずWebpackを使い、以下の設定で...」

✅ 代わりに：
「ビルドツールを選択する際は、プロジェクトの規模と要件を考慮」
```

### 3. 絶対的な禁止事項
```markdown
❌ 避けるべき記述：
「絶対にXを使うな」

✅ 代わりに：
「Xは〇〇の問題があるため、△△の場合のみ検討」
```

## 🎨 文体とトーン

### 指示的 vs 協調的
```markdown
指示的（時に必要）:
"セキュリティに関わる部分では、検証を省略しない"

協調的（基本姿勢）:
"より良い方法があれば、理由とともに提案を歓迎"
```

### 簡潔性の原則
```markdown
# 自明な部分は省略
<!-- コメント: 基本的なプログラミング知識は前提とする -->
<!-- コメント: 言語仕様の説明は不要 -->
```

## 🔍 品質チェックリスト

カスタムインストラクションを書いた後、以下を確認：

- [ ] **創造性テスト**: 「今まで見たことない要求」に対応できるか？
- [ ] **汎用性テスト**: 異なる技術スタックでも応用可能か？
- [ ] **明確性テスト**: AIが迷わず判断できる基準があるか？
- [ ] **簡潔性テスト**: 不要な具体例を削除したか？
- [ ] **本質性テスト**: 「なぜ」が明確で「何を」に偏っていないか？

## 💡 メタ認知の促進

良いカスタムインストラクションは、AIに「考え方」を教える：

```markdown
## 自己評価の習慣
実装後、以下を自問する：
- この解決策の前提は何か？
- 別のアプローチを取るとしたら？
- 6ヶ月後の自分（や他者）が理解できるか？
```

## 📊 効果測定

カスタムインストラクションの成功指標：
- AIが未知の問題を解決できた回数
- 創造的な解決策の生成頻度
- ユーザーからの追加質問の減少
- 一貫性のある判断の実現

---

## 最終確認

このガイド自体がカスタムインストラクションの良い例となっているか？
- 具体的な実装を強制していない ✓
- 思考プロセスを導いている ✓
- 創造性の余地を残している ✓
- 判断基準が明確である ✓

*Remember: カスタムインストラクションは地図であり、目的地ではない。*