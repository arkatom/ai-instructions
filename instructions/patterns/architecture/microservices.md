# Microservices Architecture

## What
アプリケーションを小さな独立したサービスの集合として構築するアーキテクチャスタイル。各サービスは単一のビジネス機能を担当し、独立してデプロイ可能。

## Why
- 独立したデプロイメント（サービス単位でリリース）
- 技術的多様性（サービスごとに最適な技術選択）
- 障害の分離（1つのサービス障害が全体に波及しない）
- スケーラビリティ（必要なサービスのみスケール）
- チームの自律性（サービス単位でチーム編成）

## Core Principles

### 1. サービス分割の原則
- **単一責任**: 1サービス1ビジネス機能
- **自律性**: 他サービスに依存せず独立動作
- **疎結合**: サービス間の依存を最小化
- **高凝集**: 関連機能を同一サービスに

### 2. 通信パターン
- **同期通信**: REST API, gRPC（即座の応答が必要）
- **非同期通信**: メッセージキュー, イベントストリーム（疎結合）
- **API Gateway**: 単一エントリーポイント

### 3. データ管理
- **データベース per サービス**: 各サービスが独自のDB
- **分散トランザクション回避**: Sagaパターン使用
- **イベントソーシング**: 状態変更をイベントとして記録

### 4. サービス発見とレジリエンス
- **サービスディスカバリー**: 動的なサービス発見
- **サーキットブレーカー**: カスケード障害防止
- **リトライ/タイムアウト**: 一時的障害への対処

## Best Practices

1. **適切なサービス境界の設定**
   - DDDの境界づけられたコンテキストを活用
   - データの整合性境界を考慮
   - チームの組織構造に合わせる（逆コンウェイの法則）

2. **API設計の標準化**
   - RESTful原則の遵守
   - バージョニング戦略の確立
   - 後方互換性の維持

3. **分散システムの複雑性への対処**
   - 分散トレーシングの実装
   - 集中ログ管理
   - メトリクス監視の充実

4. **データ整合性の管理**
   - 結果整合性の受け入れ
   - Sagaパターンでのトランザクション管理
   - イベント駆動での同期

5. **デプロイメントとCI/CD**
   - コンテナ化（Docker）
   - オーケストレーション（Kubernetes）
   - 自動化されたテストとデプロイ

6. **セキュリティ**
   - サービス間認証（mTLS）
   - APIゲートウェイでの認可
   - シークレット管理

## Simple Example

```pseudocode
// Order Service
Service OrderService {
  API:
    POST /orders - 注文作成
    GET /orders/{id} - 注文取得
  
  createOrder(orderData) {
    // 在庫確認（Inventory Service呼び出し）
    // 注文作成
    // OrderCreatedイベント発行
  }
}

// Inventory Service
Service InventoryService {
  API:
    GET /inventory/{productId} - 在庫確認
    PUT /inventory/reserve - 在庫予約
  
  EventHandler:
    on OrderCreated -> 在庫減少
    on OrderCancelled -> 在庫戻し
}

// API Gateway
Gateway {
  route("/api/orders/*") -> OrderService
  route("/api/products/*") -> ProductService
  authentication()
  rateLimit()
}
```

## Anti-patterns

1. **分散モノリス**
   - サービス間の同期的依存が多い
   - 全サービスを同時デプロイ必要
   - データベース共有

2. **過度な細分化**
   - サービスが小さすぎる
   - ネットワーク通信のオーバーヘッド
   - 運用複雑性の増大

3. **不適切なサービス境界**
   - 頻繁なサービス間通信
   - 分散トランザクションの必要性
   - データの重複

4. **共有ライブラリの乱用**
   - サービス間の暗黙的結合
   - 独立デプロイメントの阻害

5. **監視の不足**
   - 分散トレーシングなし
   - ログの分散
   - メトリクスの欠如

## Distributed Patterns

### Saga Pattern
- 長時間実行トランザクションの管理
- 補償トランザクションでロールバック
- Choreography（イベント駆動）vs Orchestration（中央制御）

### Circuit Breaker
- 障害サービスへの呼び出し停止
- 自動復旧の試行
- カスケード障害の防止

### CQRS
- 読み取りと書き込みの分離
- イベントソーシングとの組み合わせ
- 結果整合性の活用

## When to Use
- 大規模で複雑なアプリケーション
- 異なるスケーラビリティ要件を持つ機能
- 複数チームでの並行開発
- 頻繁な機能更新が必要
- 技術的多様性が必要

## When NOT to Use
- 小規模・シンプルなアプリケーション
- 少人数チーム
- データ整合性が厳密に必要
- 運用の複雑性を管理できない
- 分散システムの経験不足