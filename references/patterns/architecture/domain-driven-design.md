# Domain-Driven Design (DDD)

## What
ドメインエキスパートと開発者が共通言語を用いて、複雑なビジネスドメインをソフトウェアにモデル化する設計手法。技術ではなくビジネスを中心に据える。

## Why
- 複雑なビジネスルールを正確にコードで表現
- ドメインエキスパートと開発者の認識齟齬を防ぐ
- ビジネスの変化に柔軟に対応できる設計
- コードがビジネスを語る（自己文書化）

## Core Principles

### 1. ユビキタス言語
- ドメインエキスパートと開発者が共有する共通言語
- コード、会話、ドキュメント全てで一貫して使用
- 技術用語ではなくビジネス用語を使用

### 2. 境界づけられたコンテキスト (Bounded Context)
- ドメインモデルが適用される明確な境界
- 各コンテキストは独自のユビキタス言語を持つ
- コンテキスト間の関係を明示的に定義

### 3. 戦略的設計
- **コアドメイン**: 競争優位性の源泉（最重要）
- **サポートドメイン**: コアを支える重要機能
- **汎用ドメイン**: 一般的な機能（外部調達可）

### 4. 戦術的設計パターン
- **エンティティ**: 識別子により同一性が保証されるオブジェクト（顧客、注文等）
- **値オブジェクト**: 属性の集合で等価性が決まる不変オブジェクト（金額、住所等）
- **アグリゲート**: トランザクション整合性を保証する集約単位（注文と注文明細等）
  - 外部からはルートエンティティ経由でのみアクセス
  - 1トランザクション = 1アグリゲートの原則
- **リポジトリ**: アグリゲート単位での永続化インターフェース
- **ドメインサービス**: 複数エンティティにまたがるビジネスロジック
- **ドメインイベント**: ビジネス上の出来事の記録（注文確定、在庫切れ等）

## Best Practices

1. **ドメインエキスパートとの継続的な対話**
   - 定期的なモデリングセッション
   - ユビキタス言語の継続的な洗練

2. **アグリゲート設計**
   - 小さく保つ（1つのトランザクション境界）
   - ルートエンティティ経由でのみアクセス
   - 不変条件を常に満たす

3. **値オブジェクトの活用**
   - プリミティブ型の代わりに使用（Email, Money等）
   - ビジネスルールをカプセル化
   - 不変性を保証

4. **ドメインイベントの活用**
   - システム間の疎結合
   - イベントソーシングへの発展
   - 監査ログの自然な実現

5. **コンテキストマップの作成**
   - コンテキスト間の関係を可視化
   - 統合パターンの明確化（共有カーネル、顧客/供給者等）

## Simple Example

```pseudocode
// 値オブジェクト
ValueObject Money {
  amount: number
  currency: string
  
  add(other: Money) {
    // 通貨チェック、計算ロジック
  }
}

// エンティティ
Entity Order {
  id: OrderId
  items: OrderItem[]
  totalAmount: Money
  
  addItem(product, quantity) {
    // ビジネスルール検証
    // イベント発行: ItemAdded
  }
}

// アグリゲート
Aggregate OrderAggregate {
  root: Order
  
  // 外部からはルート経由でのみアクセス
  placeOrder() {
    // 不変条件の確認
    // OrderPlaced イベント発行
  }
}
```

## Anti-patterns

1. **貧血ドメインモデル**
   - ロジックのないデータ構造だけのエンティティ
   - ビジネスロジックがサービス層に漏れる

2. **過度に大きなアグリゲート**
   - パフォーマンス問題
   - 並行性の問題

3. **技術的な概念の混入**
   - SaveメソッドをEntityに実装
   - SQLクエリをドメイン層に記述

4. **ユビキタス言語の不統一**
   - 同じ概念に複数の名前
   - コードと会話で異なる用語

5. **境界の曖昧なコンテキスト**
   - 責務が不明確
   - モデルの汚染

## When to Use
- **複雑なビジネスドメイン**: 20以上のビジネスエンティティ、複雑な業務フロー
- **ドメインエキスパート協力**: 週2回以上のモデリングセッション可能
- **長期プロジェクト**: 2年以上の継続開発
- **チーム規模**: 3人以上、DDDの基礎知識あり
- **変化の多いドメイン**: 月3回以上のビジネスルール変更

## When NOT to Use
- **単純なアプリ**: 5エンティティ未満のCRUD中心
- **技術中心システム**: データ処理、計算処理が主体
- **短期プロジェクト**: 3ヶ月未満の開発期間
- **ドメインエキスパート不在**: ビジネス知識の提供者なし
- **小規模チーム**: 1-2人、DDD未経験

## Security Considerations  
- **アグリゲート境界**: トランザクション境界でのデータ整合性保護
- **値オブジェクト検証**: 不変性による不正データ防止
- **ドメインイベント**: 監査証跡の自動生成
- **コンテキスト境界**: 認証・認可の実装ポイント
- **腐敗防止層**: 外部システムからの不正データ防御

## Progressive Adoption
1. **Phase 1 - ユビキタス言語** (1-2週間)
   - ドメインエキスパートとの用語統一
   - 用語集の作成とレビュー

2. **Phase 2 - コアドメイン特定** (2-3週間)
   - 競争優位性の源泉を特定
   - 境界づけられたコンテキストの初期定義

3. **Phase 3 - 戦術的パターン** (3-4週間)
   - エンティティ、値オブジェクト実装
   - アグリゲート境界の設定

4. **Phase 4 - イベント駆動** (2-3週間)
   - ドメインイベントの実装
   - イベントストーミングセッション

## Related Patterns
- **Clean Architecture**: DDDのエンティティをCleanのEntity層に配置
- **Microservices**: 境界づけられたコンテキスト = マイクロサービス境界
- **Event Sourcing**: ドメインイベントを永続化
- **CQRS**: 読み書きモデルの分離でDDDを補完

## Context Mapping Patterns
1. **共有カーネル**: 複数コンテキストで共有するコア
2. **顧客/供給者**: 上流/下流の関係
3. **順応者**: 下流が上流に合わせる
4. **腐敗防止層**: レガシーシステムとの境界
5. **公開ホストサービス**: 標準化されたプロトコル
6. **発行済み言語**: 文書化された交換形式